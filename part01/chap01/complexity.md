## 복잡도(Complexity)

- 복잡도는 알고리즘의 성능을 나타내는 척도이다.
- 복잡도는 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 나눌 수 있다.
    - **시간 복잡도**는 특정한 크기의 입력에 대해 알고리즘이 얼마나 오래 걸리는지를 의미한다.
    - **공간 복잡도**는 특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다.
- 동일한 기능을 수행하는 알고리즘이 있다면 **일반적으로 복잡도가 낮을수록 좋은 알고리즘이다.**
- 복잡도를 측정함으로써 우리는 다음의 2가지를 계산할 수 있다.
    - 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수
    - 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양
- 효율적인 알고리즘을 사용한다고 했을 때 보통 시간 복잡도와 공간 복잡도는 일종의 거래 관계가 성립한다.
    - 메모리를 조금 더 많이 사용하는 대신 반복되는 연산을 생략하거나 더 많은 정보를 관리하면서 계산의 복잡도를 줄일 수 있다.
    - 이 때 **메모리를 더 소모하는 대신에 얻을 수 있는 시간적 이점이 매우 큰 경우가 종종 있다.**
    - 실제로 메모리를 더 많이 사용해서 시간을 비약적으로 줄이는 방법으로 메모이제이션(Memoization) 기법이 있다.

## 시간 복잡도

- 알고리즘을 풀 때 단순히 복잡도라고 하면 일반적으로 시간 복잡도를 의미한다.
- 코딩 테스트에서 **‘시간 제한’은 작성한 프로그램이 모든 입력을 받아 이를 처리하고 실행 결과를 출력하는데 걸리는 시간을 의미한다.**
    - 따라서 프로그램을 비효율적으로 작성하여 시간 제한을 넘기면 시간초과와 함께 오답으로 처리된다.
- 시간 복잡도를 표현할 때는 빅오 표현법을 사용한다.
    - 빅오 표기법을 간단히 말하자면, **가장 빠르게 증가하는 항만을 고려하는 표기법이다.**
    - 다시 말해 함수의 상한만을 나타낸다.
- 퀵 정렬의 평균 시간 복잡도는 O(Nlog N)이지만, 최악의 경우 시간 복잡도가 O(N^2)이다.
    - 일반적으로 코딩테스트에서는 최악의 경우에 대한 연산 횟수가 가장 중요하다.
    - 그러나 최악의 경우 시간 복잡도를 우선적으로 고려해야 한다.
- 흔한 케이스는 아니지만, 실제 코딩 테스트에서는 차수가 작은 항들을 완전히 무시하는 것도 곤란하다.
    - 연산 횟수가 3N^3 + 5N^2 + 1,000,000 인 경우, 빅오 표기법에서는 O(N^3)이지만 실제로는 1,000,000이 미치는 영향력이 크다.
    - 빅오 표기법이 절대적인 것이 아니라는 점을 기억하자.
- 컴퓨터 과학에서는 특정한 알고리즘의 시간 복잡도가 O(N^k)일 때, (이 때 k는 상수 값을 가진다.) 이를 **‘다항 시간에 동작하는 알고리즘’**이라고 말한다.
    - 이차 시간, 삼차 시간 등이 모두 다항 시간에 해당한다.
    - 이론적으로는 특정한 문제가 이러한 다항 시간 알고리즘으로 풀 수 있을 때 해당 알고리즘은 풀 만한 알고리즘으로 분류되지만, 실제로는 그렇지 않다.

### 예제

```python
array = [3, 5, 1, 2, 4]
summary = 0

# 모든 데이터를 하나씩 확인하며 합계를 계산
for x in array:
	summary += x

# 결과를 출력
print(summary)
```

- 위 코드는 5개의 데이터를 받아 차례로 5회 더해준다.
- 이 때, 연산 횟수는 N에 비례한다.
- 위 코드에서 **가장 영향력이 큰 부분은 N에 비례하는 연산을 수행하는 반복문 부분이므로 시간 복잡도를 O(N)이라고 표기한다.**

```python
a = 5
b = 7
print(a + b)
```

- a와 b에 값을 대입하는 대입 연산과 출력 함수를 무시하고 보면, 이 소스코드의 연산 횟수는 1이다.
    - 단순히 더하기 연산 한 번이 수행되기 때문이다.
- 이는 상수 연산이므로 시간 복잡도는 O(1)

```python
array = [3, 5, 1, 2, 4]  # 5개의 데이터(N = 5)

for i in array:
	for j in array:
		temp = i * j
		print(temp)
```

- O(N^2)의 시간 복잡도를 가진다.
- 2중 반복문을 이용해 각 원소에 대해 다른 모든 원소에 대한 곱셈 결과를 매번 출력하기 때문이다.
- 하지만, 모든 2중 반복문의 시간 복잡도가 O(N^2)은 아니다.
    - 만약 소스코드가 내부적으로 다른 함수를 호출한다면, 내부 함수의 시간 복잡도까지 고려해야 한다.